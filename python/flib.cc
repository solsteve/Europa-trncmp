// ====================================================================== BEGIN FILE =====
// **                                      F L I B                                      **
// =======================================================================================

#include <flib.hh>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#define INIT_VAR(a) state(a), current(-1), num_state(a), metric(0)



// =======================================================================================
void FLIB::destroy( void ) {
  // -------------------------------------------------------------------------------------
  if ( (int*)0 != state ) { delete state; }
}


// =======================================================================================
void seed_set( long int ss ) {
  // -------------------------------------------------------------------------------------
  long int seed = ss;
  if (0 == seed) {
    int fd = open("/dev/urandom", O_RDONLY);
    while ((long int)sizeof(seed) > read(fd, (void*)(&seed), sizeof(seed))) {}
    close(fd);
  }

  srand48(seed);
}




// =======================================================================================
void FLIB::init( int ns, bool r ) {
  // -------------------------------------------------------------------------------------
  if ( (int*)0 != state ) { delete state; }
  state     = new int[ ns * 4 ];
  num_state = ns;
  current   = -1;
  metric     = 0.0e0;
  if ( r ) {
    randomize();
  }
  
}


// =======================================================================================
FLIB::FLIB( void ) : INIT_VAR(0) {
  // -------------------------------------------------------------------------------------
}


// =======================================================================================
FLIB::FLIB( int ns, bool r ) : INIT_VAR(0) {
  // -------------------------------------------------------------------------------------
  init( ns );
  if ( r ) { randomize(); }
}


// =======================================================================================
FLIB::FLIB( FLIB* src ) : INIT_VAR(0) {
  // -------------------------------------------------------------------------------------
  init( src->num_state );
  copy( src );
}


// =======================================================================================
FLIB::~FLIB( void ) {
  // -------------------------------------------------------------------------------------
  destroy();
}


// =======================================================================================
void FLIB::randomize( void ) {
  // -------------------------------------------------------------------------------------
  int* ptr = state;
  for ( int i=0; i<num_state; i++ ) {
    *ptr++ = roll( num_state );
    *ptr++ = rbit( 0.3 );
    *ptr++ = roll( num_state );
    *ptr++ = rbit( 0.3 );
  }
}


// =======================================================================================
void FLIB::copy( FLIB* src ) {
  // -------------------------------------------------------------------------------------
  int nm = num_state * 4;
  for ( int i=0; i<nm; i++ ) {
    state[i] = src->state[i];
  }
  current = src->current;
  metric   = 0.0e0;
}


// =======================================================================================
void FLIB::reset( void ) {
  // -------------------------------------------------------------------------------------
  current = 0;
  metric   = 0.0e0;
}


// =======================================================================================
void FLIB::set( int new_state ) {
  // -------------------------------------------------------------------------------------
  current = new_state;
  metric   = 0.0e0;
}


// =======================================================================================
int FLIB::step( int inp ) {
  // -------------------------------------------------------------------------------------
  int* rec = (state+(current*4));

  if ( 0 == inp ) {
    current = rec[0];
    return    rec[1];
  }
  
  current = rec[2];
  return    rec[3];
}


// =======================================================================================
double FLIB::score( int* pat, int n, int m ) {
  // -------------------------------------------------------------------------------------
  metric        = 0.0e0;
  reset();
  int current = pat[0];
  for ( int i=1; i<m; i++ ) {
    int actual  = pat[i%n];
    int predict = step( current );
    if ( actual == predict ) {
      metric += 1.0e0;
    }
    current = actual;
  }

  metric /= (double)(m-1);
  
  return metric;
}


// =======================================================================================
void FLIB::display( FILE* fp, bool sd ) {
  // -------------------------------------------------------------------------------------
  int* P = state;
    for ( int i=0; i<num_state; i++ ) {
      if (sd) {
        fprintf( fp,
               "[(%d %d)(%d %d)]",
               P[0], P[1], P[2], P[3] );
      } else {
      fprintf( fp,
               "%3d => ( %3d %d ) ( %3d %d )\n",
               i, P[0], P[1], P[2], P[3] );
      }
      P += 4;
    }
      if (sd) {
        fprintf( fp, "\n" );
      }
}


// =======================================================================================
void FLIB::mutate( FLIB* dr, FLIB* sr, double pmutate ) {
  // -------------------------------------------------------------------------------------
  int* dst = dr->state;
  int* src = sr->state;
  
  for ( int i=0; i<sr->num_state; i++ ) {
    // -----------------------------------------------------
    if ( thresh(pmutate) ) {
      //fprintf( stdout, "1" );
      *dst = roll( sr->num_state );
    } else {
      //fprintf( stdout, "0" );
      *dst = *src;
    }
    src++; dst++;
    // -----------------------------------------------------
    if ( thresh(pmutate) ) {
      //fprintf( stdout, "1" );
      *dst = (*src+1)%2;
    } else {
      //fprintf( stdout, "0" );
      *dst = *src;
    }
    src++; dst++;
    // -----------------------------------------------------
    if ( thresh(pmutate) ) {
      //fprintf( stdout, "1" );
      *dst = roll( sr->num_state );
    } else {
      //fprintf( stdout, "0" );
      *dst = *src;
    }
    src++; dst++;
    // -----------------------------------------------------
    if ( thresh(pmutate) ) {
      //fprintf( stdout, "1" );
      *dst =  (*src+1)%2;
    } else {
      //fprintf( stdout, "0" );
      *dst = *src;
    }
    src++; dst++;
  }
  
  //fprintf( stdout, "\n" );
 
  dr->reset();
}

// =======================================================================================
void FLIB::cross( FLIB* C1, FLIB* C2, FLIB* P1, FLIB* P2 ) {
  // -------------------------------------------------------------------------------------
  int* c1 = C1->state;
  int* c2 = C2->state;
  int* p1 = P1->state;
  int* p2 = P2->state;

  int nm =  P1->num_state * 4;
  int nh = (P1->num_state * 2) - 2;

  int a =      1 + roll(nh);
  int b = nh + 1 + roll(nh);

  for ( int i=0; i<a; i++ ) {
    *c1++ = *p1++;
    *c2++ = *p2++;
  }

  for ( int i=a; i<b; i++ ) {
    *c1++ = *p2++;
    *c2++ = *p1++;
  }

  for ( int i=b; i<nm; i++ ) {
    *c1++ = *p1++;
    *c2++ = *p2++;
  }

}


// =======================================================================================
int* FLIB::toState( void ) {
  // -------------------------------------------------------------------------------------
  int np = num_state * 4;
  int* P = new int[np];
  for ( int i=0; i<np; i++ ) {
    P[i] = state[i];
  }
  return P;
}


// =======================================================================================
void FLIB::fromState( int* param, int ns ) {
  // -------------------------------------------------------------------------------------
  if ( num_state != ns ) {
    destroy();
    init( ns );
  }
  int np = num_state * 4;
  for ( int i=0; i<np; i++ ) {
    state[i] = param[i];
  }
}


// =======================================================================================
// **                                      F L I B                                      **
// =========================================================================== END FILE ==
