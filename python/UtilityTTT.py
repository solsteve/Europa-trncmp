import sys
import numpy as np
import numpy.random as rnd


#/ =======================================================================================
def QInit():
    #/ -----------------------------------------------------------------------------------
    return 0.01


#/ =======================================================================================
def LoadQTable( fspc ):
    #/ -----------------------------------------------------------------------------------
    tab = {}
    fp = open( fspc, 'r' )
    for line in fp:
        state = line[:9]
        rec   = []
        for idx in range(9,18):
            try:
                n = int(line[idx])
                rec.append(n)
            except ValueError:
                pass
        tab[state] = [QInit(), rec]
    fp.close()
    return tab


#/ =======================================================================================
def NextState( state, idx, mark ):
    #/ -----------------------------------------------------------------------------------
    ns = state[0]
    if ( 0 == idx ): ns = mark
    for i in range(1,9):
        if ( i==idx ):
            ns = '%s%s' % ( ns, mark, )
        else:
            ns = '%s%s' % ( ns, state[i], )
    return ns


#/ =======================================================================================
def Reward( Q, state ):
    #/ -----------------------------------------------------------------------------------
    return Q[state][0]


#/ =======================================================================================
def NextMoves( Q, state ):
    #/ -----------------------------------------------------------------------------------
    return Q[state][1]


#/ =======================================================================================
def TakeAction( Q, state, action ):
    #/ -----------------------------------------------------------------------------------
    entry = Q[state]
    nm = entry[1][action]
    ns = nextState(state,nm,'o')
    entry = Q[ns]
    R = entry[0]
    return (ns, R)


#/ =======================================================================================
def MaxArgs( a ):
    #/ -----------------------------------------------------------------------------------
    mxv = np.max(a)
    n   = len(a)
    mxi = []
    for i in range(n):
        if ( mxv == a[i] ):
            mxi.append(i)
    return mxi


#/ =======================================================================================
def MaxAction( Q, state, eps ):
    #/ -----------------------------------------------------------------------------------
    nm = NextMoves(Q,state)
    A = []
    R = []
    for m in nm:
        A.append( m )
        ns = NextState( state, m, 'o' )
        R.append( Reward( Q, ns ) )
    if ( eps < rnd.uniform() ):
        idx = MaxArgs(R)
        n = len(idx)
        if ( 1 == idx ):
            return A[idx[0]]
        return A[idx[rnd.randint(n)]]

    n = len(nm)
    return A[idx[rnd.randint(n)]]
    
#/ =======================================================================================
def Display( state ):
    #/ -----------------------------------------------------------------------------------
    print( ' %s | %s | %s ' % ( state[0], state[1], state[2], ) )
    print( '---+---+---' )
    print( ' %s | %s | %s ' % ( state[3], state[4], state[5], ) )
    print( '---+---+---' )
    print( ' %s | %s | %s ' % ( state[6], state[7], state[8], ) )



epsilon = 0.2

state = '.........'

