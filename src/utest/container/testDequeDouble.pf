module testDequeDouble
  use trncmp_env
  use pfunit_mod
  use double_deque_class
  implicit none

  integer, parameter :: SAMPLES = 100

contains

 !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_PP
    type(DoubleDeque) :: Q
    integer           :: i, j, k, stat

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=SAMPLES,1,-1
       j = int( Q%pop(stat) )
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_PP

  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_AR
    type(DoubleDeque) :: Q
    integer           :: i, j, k, stat

    do i=1,SAMPLES
       call Q%assert( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=SAMPLES,1,-1
       j = int( Q%retract(stat) )
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_AR

  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_AP
    type(DoubleDeque) :: Q
    integer            :: i, j, k, stat

    do i=1,SAMPLES
       call Q%assert( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=1,SAMPLES
       j = int(Q%pop(stat))
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_AP

  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_PR
    type(DoubleDeque) :: Q
    integer            :: i, j, k, stat

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=1,SAMPLES
       j = int(Q%retract(stat))
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_PR

  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_clear
    type(DoubleDeque) :: Q
    integer            :: i

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    call Q%clear(del=.true.)

    @assertEqual( 0, Q%size() )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_clear

  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_peek
    type(DoubleDeque) :: Q
    integer            :: i, a, b, stat

    do i=1,SAMPLES
       call Q%assert( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    a = int( Q%peekHead( stat ) )
    @assertEqual( a, 1 )
    @assertEqual( 0, stat )

    b = int( Q%peekTail(stat) )
    @assertEqual( b, SAMPLES )
    @assertEqual( 0, stat )

    call Q%clear(del=.true.)

    @assertEqual( 0, Q%size() )
    @assertTrue( Q%empty() )

    a = int( Q%peekHead( stat ) )
    @assertEqual( a, -1 )
    @assertEqual( 1, stat )

    b = int( Q%peekTail(stat) )
    @assertEqual( b, -1 )
    @assertEqual( 1, stat )

  end subroutine testDoubleDeque_peek


  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_convert
    real(dp)          :: a, b
    integer           :: s
    class(*), pointer :: P
    character(32)     :: msg
    msg = ''
    a = 7.3

    P => double2object( a )
    b = object2double( P, s, msg )

    @assertFalse( a .lt. b )
    @assertFalse( a .gt. b )

  end subroutine testDoubleDeque_convert



  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_iterate_next
    type(DoubleDeque) :: Q
    integer            :: i, j, k

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    call Q%head

    k = 0
    i = SAMPLES
    it_loop: do
        if ( Q%hasNext() ) then
          j = int( Q%next() )
          if ( i.ne.j ) k = k + 1
       else
          exit it_loop
       end if
      i = i - 1
    end do it_loop
    
    @assertEqual( 0, k )

  end subroutine testDoubleDeque_iterate_next

  
  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_iterate_prev
    type(DoubleDeque) :: Q
    integer            :: i, j, k

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    call Q%tail

    k = 0
    i = 1
    it_loop: do
        if ( Q%hasPrev() ) then
          j = int( Q%prev() )
          if ( i.ne.j ) k = k + 1
       else
          exit it_loop
       end if
      i = i + 1
    end do it_loop
    
    @assertEqual( 0, k )
    
  end subroutine testDoubleDeque_iterate_prev


  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_repeat_add_rem
    type(DoubleDeque) :: Q
    integer           :: i
    !/ -----------------------------------------------

    @assertEqual( 0, Q%size() )
    call Q%add(1.0_dp)
    call Q%add(2.0_dp)
    call Q%add(3.0_dp)
    @assertEqual( 3, Q%size() )

    !/ -----------------------------------------------
    i = int(Q%remove())
    i = i + int(Q%remove())
    i = i + int(Q%remove())
    @assertEqual( 6, i )
    @assertTrue( Q%empty() )

    !/ -----------------------------------------------
    do i=1,3
       call Q%add(real(i,dp))
    end do
    @assertEqual( 3, Q%size() )

    call Q%clear
    @assertTrue( Q%empty() )


  end subroutine testDoubleDeque_repeat_add_rem

  
end module testDequeDouble
