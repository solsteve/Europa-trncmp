module testDequeDouble
  use pfunit_mod
  use integer_deque_class
  implicit none

  integer, parameter :: SAMPLES = 100

contains

  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_PP
    type(DoubleDeque) :: Q
    integer            :: i, j, k, stat

    do i=1,SAMPLES
       call Q%push( i )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=SAMPLES,1,-1
       j = Q%pop(stat)
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_PP


  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_AR
    type(DoubleDeque) :: Q
    integer            :: i, j, k, stat

    do i=1,SAMPLES
       call Q%assert( i )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=SAMPLES,1,-1
       j = Q%retract(stat)
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_AR


  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_AP
    type(DoubleDeque) :: Q
    integer            :: i, j, k, stat

    do i=1,SAMPLES
       call Q%assert( i )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=1,SAMPLES
       j = Q%pop(stat)
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_AP


  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_PR
    type(DoubleDeque) :: Q
    integer            :: i, j, k, stat

    do i=1,SAMPLES
       call Q%push( i )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=1,SAMPLES
       j = Q%retract(stat)
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_PR


  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_clear
    type(DoubleDeque) :: Q
    integer            :: i

    do i=1,SAMPLES
       call Q%push( i )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    call Q%clear(del=.true.)

    @assertEqual( 0, Q%size() )
    @assertTrue( Q%empty() )

  end subroutine testDoubleDeque_clear


  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_peek
    type(DoubleDeque) :: Q
    integer            :: i, a, b, stat

    do i=1,SAMPLES
       call Q%assert( i )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    a = Q%peekHead( stat )
    @assertEqual( a, 1 )
    @assertEqual( 0, stat )

    b = Q%peekTail(stat)
    @assertEqual( b, SAMPLES )
    @assertEqual( 0, stat )

    call Q%clear(del=.true.)

    @assertEqual( 0, Q%size() )
    @assertTrue( Q%empty() )

    a = Q%peekHead( stat )
    @assertEqual( a, -1 )
    @assertEqual( 1, stat )

    b = Q%peekTail(stat)
    @assertEqual( b, -1 )
    @assertEqual( 1, stat )

  end subroutine testDoubleDeque_peek


  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_convert
    integer           :: a, b, s
    class(*), pointer :: P
    character(32)     :: msg
    msg = ''
    a = 7

    P => integer2object( a )
    b = object2integer( P, s, msg )

    @assertEqual( a, b )

  end subroutine testDoubleDeque_convert


  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_iterate_next
    type(DoubleDeque) :: Q
    integer            :: i, j, k

    do i=1,SAMPLES
       call Q%push( i )
    end do

    call Q%head

    k = 0
    i = SAMPLES
    it_loop: do
        if ( Q%hasNext() ) then
          j = Q%next()
          if ( i.ne.j ) k = k + 1
       else
          exit it_loop
       end if
      i = i - 1
    end do it_loop
    
    @assertEqual( 0, k )

  end subroutine testDoubleDeque_iterate_next

  
  !/ -----------------------------------------------
  @test
  subroutine testDoubleDeque_iterate_prev
    type(DoubleDeque) :: Q
    integer            :: i, j, k

    do i=1,SAMPLES
       call Q%push( i )
    end do

    call Q%tail

    k = 0
    i = 1
    it_loop: do
        if ( Q%hasPrev() ) then
          j = Q%prev()
          if ( i.ne.j ) k = k + 1
       else
          exit it_loop
       end if
      i = i + 1
    end do it_loop
    
    @assertEqual( 0, k )
    
  end subroutine testDoubleDeque_iterate_prev

  @test
  subroutine testDoubleDeque_repeat_add_rem
    type(DoubleDeque) :: Q
    integer            :: i
    !/ -----------------------------------------------

    @assertEqual( 0, Q%size() )
    call Q%add(1)
    call Q%add(2)
    call Q%add(3)
    @assertEqual( 3, Q%size() )

    !/ -----------------------------------------------
    i = Q%remove()
    i = i + Q%remove()
    i = i + Q%remove()
    @assertEqual( 6, i )
    @assertTrue( Q%empty() )

    !/ -----------------------------------------------
    do i=1,3
       call Q%add(i)
    end do
    @assertEqual( 3, Q%size() )

    call Q%clear
    @assertTrue( Q%empty() )


  end subroutine testDoubleDeque_repeat_add_rem

 
end module testDequeDouble
