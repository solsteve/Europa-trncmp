module testDequeDouble
  use trncmp_env
  use pfunit_mod
  use deque_double_class
  implicit none

  integer, parameter :: SAMPLES = 100

contains

 !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_PP
    type(DequeDouble) :: Q
    integer           :: i, j, k, stat

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=SAMPLES,1,-1
       j = int( Q%pop(stat) )
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDequeDouble_PP

  !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_AR
    type(DequeDouble) :: Q
    integer           :: i, j, k, stat

    do i=1,SAMPLES
       call Q%assert( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=SAMPLES,1,-1
       j = int( Q%retract(stat) )
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDequeDouble_AR

  !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_AP
    type(DequeDouble) :: Q
    integer            :: i, j, k, stat

    do i=1,SAMPLES
       call Q%assert( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=1,SAMPLES
       j = int(Q%pop(stat))
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDequeDouble_AP

  !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_PR
    type(DequeDouble) :: Q
    integer            :: i, j, k, stat

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    k = 0
    do i=1,SAMPLES
       j = int(Q%retract(stat))
       if ( 0.ne.stat ) k = k + 1
       if ( i.ne.j )    k = k + 1
    end do

    @assertEqual( 0, Q%size() )
    @assertEqual( 0, k )
    @assertTrue( Q%empty() )

  end subroutine testDequeDouble_PR

  !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_clear
    type(DequeDouble) :: Q
    integer            :: i

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    call Q%clear(del=.true.)

    @assertEqual( 0, Q%size() )
    @assertTrue( Q%empty() )

  end subroutine testDequeDouble_clear

  !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_peek
    type(DequeDouble) :: Q
    integer            :: i, a, b, stat

    do i=1,SAMPLES
       call Q%assert( real(i,dp) )
    end do

    @assertEqual( SAMPLES, Q%size() )
    @assertFalse( Q%empty() )

    a = int( Q%peekHead( stat ) )
    @assertEqual( a, 1 )
    @assertEqual( 0, stat )

    b = int( Q%peekTail(stat) )
    @assertEqual( b, SAMPLES )
    @assertEqual( 0, stat )

    call Q%clear(del=.true.)

    @assertEqual( 0, Q%size() )
    @assertTrue( Q%empty() )

    a = int( Q%peekHead( stat ) )
    @assertFalse( a .lt. 0.0_dp )
    @assertFalse( a .gt. 0.0_dp )
    @assertEqual( 1, stat )

    b = int( Q%peekTail(stat) )
    @assertFalse( b .lt. 0.0_dp )
    @assertFalse( b .gt. 0.0_dp )
    @assertEqual( 1, stat )

  end subroutine testDequeDouble_peek


  !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_convert
    real(dp)          :: a, b
    integer           :: s
    class(*), pointer :: P
    character(32)     :: msg
    msg = ''
    a = 7.3

    P => double2object( a )
    b = object2double( P, s, msg )

    @assertFalse( a .lt. b )
    @assertFalse( a .gt. b )

  end subroutine testDequeDouble_convert



  !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_iterate_next
    type(DequeDouble) :: Q
    integer            :: i, j, k

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    call Q%head

    k = 0
    i = SAMPLES
    it_loop: do
        if ( Q%hasNext() ) then
          j = int( Q%next() )
          if ( i.ne.j ) k = k + 1
       else
          exit it_loop
       end if
      i = i - 1
    end do it_loop
    
    @assertEqual( 0, k )

  end subroutine testDequeDouble_iterate_next

  
  !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_iterate_prev
    type(DequeDouble) :: Q
    integer            :: i, j, k

    do i=1,SAMPLES
       call Q%push( real(i,dp) )
    end do

    call Q%tail

    k = 0
    i = 1
    it_loop: do
        if ( Q%hasPrev() ) then
          j = int( Q%prev() )
          if ( i.ne.j ) k = k + 1
       else
          exit it_loop
       end if
      i = i + 1
    end do it_loop
    
    @assertEqual( 0, k )
    
  end subroutine testDequeDouble_iterate_prev


  !/ -----------------------------------------------
  @test
  subroutine testDequeDouble_repeat_add_rem
    type(DequeDouble) :: Q
    integer           :: i
    !/ -----------------------------------------------

    @assertEqual( 0, Q%size() )
    call Q%add(1.0_dp)
    call Q%add(2.0_dp)
    call Q%add(3.0_dp)
    @assertEqual( 3, Q%size() )

    !/ -----------------------------------------------
    i = int(Q%remove())
    i = i + int(Q%remove())
    i = i + int(Q%remove())
    @assertEqual( 6, i )
    @assertTrue( Q%empty() )

    !/ -----------------------------------------------
    do i=1,3
       call Q%add(real(i,dp))
    end do
    @assertEqual( 3, Q%size() )

    call Q%clear
    @assertTrue( Q%empty() )


  end subroutine testDequeDouble_repeat_add_rem

  
end module testDequeDouble
